require('dotenv').config();
const express = require('express');
const axios = require('axios');
const cors = require('cors');
const bodyParser = require('body-parser');
const { handleSmartAdvice } = require('./smartWeatherAdvisor');

// ì„œë²„ ì‹œì‘ ì‹œ API í‚¤ í™•ì¸ (í…ŒìŠ¤íŠ¸)
console.log('=== API í‚¤ ìƒíƒœ í™•ì¸ ===');
console.log('Gemini API í‚¤:', process.env.GEMINI_API_KEY ? 'ìˆìŒ' : 'ì—†ìŒ');
console.log('OpenWeather API í‚¤:', process.env.OPENWEATHER_API_KEY ? 'ìˆìŒ' : 'ì—†ìŒ');


// Module import
const { getUserProfile } = require('./userProfileUtils');
const { geocodeGoogle, reverseGeocode } = require('./locationUtils');
const { getWeather, getWeatherByCoords } = require('./weatherUtils');
const conversationStore = require('./conversationStore');
const { extractDateFromText, getNearestForecastTime } = require('./timeUtils');
const { extractLocationFromText } = require('./placeExtractor');
const weatherAdvice = require('./weatherAdviceRouter');

const app = express();
const PORT = 4000;

// âœ… í•„ìˆ˜ API í‚¤
// í‚¤ ì™¸ë¶€ ë…¸ì¶œì„ ë§‰ê¸° ìœ„í•´ ë°°í¬ í›„ .env íŒŒì¼ë¡œ ë¶„ë¦¬í•  ìˆ˜ ìˆìŒ.
const GEMINI_API_KEY       = process.env.GEMINI_API_KEY;
const OPENWEATHER_API_KEY  = process.env.OPENWEATHER_API_KEY;
const GOOGLE_MAPS_API_KEY  = process.env.GOOGLE_MAPS_API_KEY;
const AMBEE_POLLEN_API_KEY = process.env.AMBEE_POLLEN_API_KEY;

app.use(cors());
app.use(bodyParser.json());


//  ì±„íŒ… ì œëª© ìë™ ìƒì„± API
app.post('/generate-title', async (req, res) => {
  const { userInput } = req.body;
  
  try {
    const prompt = `
Generate a concise English title for this weather-related conversation based on the user's question.

Rules:
- Maximum 4 words
- Use title case (First Letter Capitalized)
- No emojis or special characters
- Focus on the main topic (weather, location, condition)
- Be specific and descriptive

User question: "${userInput}"

Examples:
"What's the weather like today?" â†’ "Todayâ€™s Weather"
"ì˜¤ëŠ˜ ë‚ ì”¨ ì–´ë•Œ?" â†’ "Todayâ€™s Weather"
"ì˜¤ëŠ˜ ì„œìš¸ ë‚ ì”¨ ì–´ë•Œ?" â†’ "Seoul Weather Today"
"ë‚´ì¼ ë¶€ì‚° ë¹„ ì˜¬ê¹Œ?" â†’ "Busan Rain Tomorrow"
"ë¯¸ì„¸ë¨¼ì§€ ë†ë„ ê¶ê¸ˆí•´" â†’ "Air Quality Check"
"ê½ƒê°€ë£¨ ì•Œë ˆë¥´ê¸° ì¡°ì‹¬í•´ì•¼ í• ê¹Œ?" â†’ "Pollen Allergy Alert"
"ì´ë²ˆì£¼ ë‚ ì”¨ ì–´ë–¨ê¹Œ?" â†’ "Weekly Weather Forecast"
"ìŠµë„ê°€ ë†’ì•„?" â†’ "Humidity Levels"

Title:`;

    const result = await axios.post(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`,
      {
        contents: [
          {
            role: 'user',
            parts: [{ text: prompt }]
          }
        ]
      }
    );

    let title = result.data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || 'New Weather Chat';
    
    // "Title:" ì ‘ë‘ì‚¬ ì œê±° ë° ì •ë¦¬
    title = title.replace(/^Title:\s*/i, '').trim();
    title = title.replace(/[""]/g, ''); // ë”°ì˜´í‘œ ì œê±°
    
    // 4ë‹¨ì–´ ì´ˆê³¼ì‹œ ìë¥´ê¸°
    const words = title.split(' ');
    if (words.length > 4) {
      title = words.slice(0, 4).join(' ');
    }
    
    console.log('ğŸ·ï¸ ìƒì„±ëœ ì œëª©:', title);
    res.json({ title });
    
  } catch (err) {
    console.error('âŒ ì œëª© ìƒì„± ì‹¤íŒ¨:', err.message);
    
    // í´ë°±: í‚¤ì›Œë“œ ê¸°ë°˜ ì˜ì–´ ì œëª© ìƒì„±
    const fallbackTitle = generateEnglishFallbackTitle(userInput);
    res.json({ title: fallbackTitle });
  }
});

// í´ë°± ì˜ì–´ ì œëª© ìƒì„± í•¨ìˆ˜ (í•œêµ­ì–´ + ì˜ì–´ ì§€ì›)
function generateEnglishFallbackTitle(input) {
  const patterns = [
    { keywords: ['ë‚ ì”¨', 'weather', 'ê¸°ì˜¨', 'ì˜¨ë„', 'temperature'], title: 'Weather Inquiry' },
    { keywords: ['ë¯¸ì„¸ë¨¼ì§€', 'pm2.5', 'pm10', 'air quality', 'pollution'], title: 'Air Quality Check' },
    { keywords: ['ê½ƒê°€ë£¨', 'ì•Œë ˆë¥´ê¸°', 'pollen', 'allergy'], title: 'Pollen Alert' },
    { keywords: ['ë¹„', 'í­ìš°', 'rain', 'shower', 'precipitation'], title: 'Rain Forecast' },
    { keywords: ['ëˆˆ', 'í­ì„¤', 'snow', 'snowfall'], title: 'Snow Forecast' },
    { keywords: ['íƒœí’', 'ë°”ëŒ', 'wind', 'typhoon', 'storm'], title: 'Wind Weather' },
    { keywords: ['ìŠµë„', 'humidity', 'moisture'], title: 'Humidity Check' },
    { keywords: ['ë‚´ì¼', 'tomorrow'], title: 'Tomorrow Weather' },
    { keywords: ['ì˜¤ëŠ˜', 'today'], title: 'Today Weather' },
    { keywords: ['ì´ë²ˆì£¼', 'week', 'weekly'], title: 'Weekly Forecast' }
  ];

  for (const pattern of patterns) {
    if (pattern.keywords.some(keyword => input.includes(keyword))) {
      return pattern.title;
    }
  }

  // ì§€ì—­ëª… ì¶”ì¶œ ì‹œë„
  const cityMap = {
    'ì„œìš¸': 'Seoul Weather',
    'ë¶€ì‚°': 'Busan Weather', 
    'ëŒ€êµ¬': 'Daegu Weather',
    'ì¸ì²œ': 'Incheon Weather',
    'ê´‘ì£¼': 'Gwangju Weather',
    'ëŒ€ì „': 'Daejeon Weather',
    'ìš¸ì‚°': 'Ulsan Weather'
  };
  
  for (const [korean, english] of Object.entries(cityMap)) {
    if (input.includes(korean)) {
      return english;
    }
  }

  return 'Weather Chat';
}

// â€¦ (getPollenAmbee, getAirQuality, classifyPm25, /reverse-geocode, /weather ì—”ë“œí¬ì¸íŠ¸ ë“±ì€ ê·¸ëŒ€ë¡œ) â€¦

// Ambee Pollen API í˜¸ì¶œ í•¨ìˆ˜ (ì‘ë‹µ êµ¬ì¡°ì— ë§ì¶° ìˆ˜ì •ë¨)
async function getPollenAmbee(lat, lon) {
  try {
    const url = 'https://api.ambeedata.com/latest/pollen/by-lat-lng';

    const res = await axios.get(url, {
      params: { lat, lng: lon },
      headers: {
        'x-api-key': AMBEE_POLLEN_API_KEY,
        'Accept': 'application/json'
      }
    });

    // ì‘ë‹µ ì „ì²´ë¥¼ ì½˜ì†”ì— ì°ì–´ì„œ ì‹¤ì œ êµ¬ì¡°ë¥¼ ì¬í™•ì¸
    console.log('ğŸŒ² Ambee ì‘ë‹µ JSON:', JSON.stringify(res.data, null, 2));

    // Ambee ì‘ë‹µ ë‚´ë¶€ì˜ data ë°°ì—´
    const arr = res.data?.data;
    if (!Array.isArray(arr) || arr.length === 0) {
      console.warn('ğŸŒ² Ambee ì‘ë‹µì— data ë°°ì—´ì´ ì—†ê±°ë‚˜ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.');
      return null;
    }

    // ì²« ë²ˆì§¸(ìœ ì¼í•œ) ê°ì²´ë¥¼ êº¼ëƒ„
    const info      = arr[0];
    const risks     = info.Risk;    // { grass_pollen: "Low", tree_pollen: "Low", weed_pollen: "Low" }
    const counts    = info.Count;   // { grass_pollen: 27, tree_pollen: 47, weed_pollen: 13 }
    const updatedAt = info.updatedAt; // "2025-06-04T11:00:00.000Z"

    if (typeof risks !== 'object' || typeof counts !== 'object') {
      console.warn('ğŸŒ² Ambee ì‘ë‹µ í˜•ì‹ì´ ì˜ˆìƒê³¼ ë‹¤ë¦…ë‹ˆë‹¤. Risk ë˜ëŠ” Count í•„ë“œê°€ ì—†ìŠµë‹ˆë‹¤.');
      return null;
    }

    // ìœ„í—˜ë„ ìš°ì„ ìˆœìœ„ ë§¤í•‘
    const priorityMap = { 'High': 3, 'Medium': 2, 'Low': 1 };

    // "ê°€ì¥ ë†’ì€ ìœ„í—˜ë„"ë¥¼ ì°¾ê¸° ìœ„í•´ ê¸°ë³¸ê°’ ì„¸íŒ…
    let topType = Object.keys(risks)[0]; // ì˜ˆ: "grass_pollen"
    for (const type of Object.keys(risks)) {
      if (priorityMap[risks[type]] > priorityMap[risks[topType]]) {
        topType = type;
      }
    }

    // ìµœì¢… ì„ íƒëœ í•­ëª©
    const topRisk  = risks[topType];    // â€œLowâ€/â€œMediumâ€/â€œHighâ€
    const topCount = counts[topType];   // ìˆ«ì
    const topTime  = updatedAt;         // ISO ë¬¸ìì—´

    // ex) { type: "grass_pollen", count: 27, risk: "Low", time: "2025-06-04T11:00:00.000Z" }
    return {
      type:  topType,
      count: topCount,
      risk:  topRisk,
      time:  topTime
    };
  } catch (err) {
    console.error('ğŸŒ² Ambee Pollen API í˜¸ì¶œ ì˜¤ë¥˜:', {
      status: err.response?.status,
      data:   err.response?.data || err.message
    });
    return null;
  }
}

// ìœ„ê²½ë„ ê¸°ë°˜ ë¯¸ì„¸ë¨¼ì§€ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
//     - v3.0 í˜¸ì¶œì´ 404(Internal error)ì¼ ê²½ìš° v2.5ë¡œ í´ë°±
async function getAirQuality(lat, lon) {
  // (A) ë¨¼ì € v3.0 ì—”ë“œí¬ì¸íŠ¸ ì‹œë„
  try {
    const urlV3 = `https://api.openweathermap.org/data/3.0/air_pollution?lat=${lat}&lon=${lon}&appid=${OPENWEATHER_API_KEY}`;
    const res3 = await axios.get(urlV3);
    const data3 = res3.data;
    const pm25 = data3.list[0].components.pm2_5;
    const pm10 = data3.list[0].components.pm10;
    return { pm25, pm10 };
  } catch (err) {
    // v3.0 í˜¸ì¶œ ì¤‘ 404(Internal error) í˜¹ì€ ê¸°íƒ€ ì—ëŸ¬ê°€ ë‚˜ë©´ ì½˜ì†”ì— ë¡œê¹…
    const status = err.response?.status;
    const msg    = err.response?.data || err.message;
    console.warn(`getAirQuality v3.0 í˜¸ì¶œ ì‹¤íŒ¨ (status: ${status}) â†’ v2.5 í´ë°± ì‹œë„:`, msg);

    // (B) v2.5 ì—”ë“œí¬ì¸íŠ¸ë¡œ í´ë°±
    try {
      const urlV25 = `https://api.openweathermap.org/data/2.5/air_pollution?lat=${lat}&lon=${lon}&appid=${OPENWEATHER_API_KEY}`;
      const res25 = await axios.get(urlV25);
      const data25 = res25.data;
      const pm25   = data25.list[0].components.pm2_5;
      const pm10   = data25.list[0].components.pm10;
      return { pm25, pm10 };
    } catch (err25) {
      console.error('getAirQuality v2.5 í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜:', err25.response?.data || err25.message);
      return null;
    }
  }
}

// ì‹¤ì‹œê°„ ìœ„ì¹˜
// 1. ìœ„ë„/ê²½ë„ë¡œ ì§€ì—­ëª… ë°˜í™˜
app.post('/reverse-geocode', async (req, res) => {
  const { latitude, longitude } = req.body;
  try {
    const region = await reverseGeocode(latitude, longitude);
    res.json({ region });
  } catch (err) {
    console.error('ğŸ“ reverse-geocode ì‹¤íŒ¨:', err.message);
    res.status(500).json({ error: 'ì£¼ì†Œ ë³€í™˜ ì‹¤íŒ¨' });
  }
});


// ì‚¬ìš©ìì˜ ìœ„ë„/ê²½ë„ë¡œ ë‚ ì”¨ ì •ë³´ë§Œ ë°˜í™˜í•˜ëŠ” API
// 2. ìœ„ë„/ê²½ë„ë¡œ ë‚ ì”¨ ì •ë³´
app.post('/weather', async (req, res) => {
  const { latitude, longitude } = req.body;
  try {
    const weather = await getWeatherByCoords(latitude, longitude);
    res.json(weather);
  } catch (err) {
    console.error('ğŸŒ§ï¸ ë‚ ì”¨ ì •ë³´ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', err.message);
    res.status(500).json({ error: 'ë‚ ì”¨ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.' });
  }
});

// 3. íŠ¹ì • ì‹œê°„ ê¸°ì˜¨ ë³€í™” ê·¸ë˜í”„ ì¶œë ¥ìš©
app.post('/weather-graph', async (req, res) => {
  const { latitude, longitude } = req.body;
  try {
    const url = `https://api.openweathermap.org/data/3.0/onecall?lat=${latitude}&lon=${longitude}&exclude=minutely,daily,alerts&appid=${OPENWEATHER_API_KEY}&units=metric&lang=kr`;
    const result = await axios.get(url);
    const data = result.data; // í•œ ë²ˆì— hourly + timezone_offset ì‚¬ìš©

    const hourly = data.hourly;
    const timezoneOffsetSec = data.timezone_offset || 0;
    const offsetMs = timezoneOffsetSec * 1000;

    // 1. í˜„ì¬ UTC ì‹œê°
    const utcNow = new Date();  // ë¬´ì¡°ê±´ UTC

    // 2. í•´ë‹¹ ì§€ì—­ í˜„ì§€ ê¸°ì¤€ ì‹œê°ì„ ê³„ì‚°
    const localNow = new Date(utcNow.getTime() + offsetMs);
    localNow.setMinutes(0, 0, 0); // ë¶„, ì´ˆ ì œê±° â†’ ì •ê°ìœ¼ë¡œ

    const hourlyTemps = [];

    for (let i = 0; i < 6; i++) {
      // 3. 3ì‹œê°„ ê°„ê²© target UTC ì‹œê° ìƒì„±
      const targetLocalTime = new Date(localNow.getTime() + i * 3 * 60 * 60 * 1000);
      const targetUTC = new Date(targetLocalTime.getTime() - offsetMs);
      // 4. UTC ê¸°ì¤€ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ hourly ë°ì´í„° ì°¾ê¸°
      const closest = hourly.reduce((prev, curr) => {
        const currTime = curr.dt * 1000;
        return Math.abs(currTime - targetUTC.getTime()) < Math.abs(prev.dt * 1000 - targetUTC.getTime()) ? curr : prev;
      });

      // 5. labelì€ í˜„ì§€ ì‹œê°„ ê¸°ì¤€
      const localTime = new Date(targetUTC.getTime() + offsetMs);
      const hour = new Date(targetUTC.getTime() + offsetMs).getUTCHours();
      const label = `${hour % 12 === 0 ? 12 : hour % 12}${hour < 12 ? 'am' : 'pm'}`;
      console.log(`âœ… label=${label} | local=${localTime.toISOString()} | UTC=${targetUTC.toISOString()} | temp=${Math.round(closest.temp)}`);

      hourlyTemps.push({
        hour: label,
        temp: Math.round(closest.temp)
      });
    }

        res.json({ hourlyTemps });
        console.log('ğŸ“¡ ìµœì¢… hourlyTemps:', hourlyTemps);

      } catch (err) {
        console.error('ğŸ“Š ì‹œê°„ë³„ ê¸°ì˜¨ ê·¸ë˜í”„ìš© API ì‹¤íŒ¨:', err.message);
        res.status(500).json({ error: 'ê·¸ë˜í”„ìš© ë‚ ì”¨ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.' });
      }
    });

app.post('/gemini', async (req, res) => {
  const { userInput, coords, uid } = req.body;
  console.log('ğŸ’¬ ì‚¬ìš©ì ì§ˆë¬¸:', userInput);

  const forecastDate = extractDateFromText(userInput);
  const forecastKey  = getNearestForecastTime(forecastDate);

  const extractedLocation = extractLocationFromText(userInput);
  console.log('ğŸ“ ì¶”ì¶œëœ ì¥ì†Œ:', extractedLocation);

  let lat, lon, locationName;

  try {
    const uid = req.body.uid || null;

    if (extractedLocation) {
      const geo = await geocodeGoogle(extractedLocation);
      if (!geo || !geo.lat || !geo.lon) {
        return res.json({ reply: `ì£„ì†¡í•´ìš”. "${extractedLocation}" ì§€ì—­ì˜ ìœ„ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ìš”.` });
      }
      lat = geo.lat;
      lon = geo.lon;
      locationName = extractedLocation;
    } else if (coords) {
      lat = coords.latitude;
      lon = coords.longitude;
      locationName = await reverseGeocode(lat, lon);
    } else {
      return res.json({ reply: 'ì–´ëŠ ì§€ì—­ì˜ ë‚ ì”¨ë¥¼ ì•Œë ¤ë“œë¦´ê¹Œìš”?' });
    }

    console.log(`ğŸ“ "${locationName}" â†’ lat: ${lat}, lon: ${lon}`);

    // âœ… ì—¬ê¸°ê¹Œì§€ í¬í•¨í•´ì„œ tryë¡œ ê°ì‹¸ì•¼ í•¨
    await handleSmartAdvice({ userInput, lat, lon, locationName, uid }, res);

  } catch (err) {
    console.error('âŒ Gemini API ì˜¤ë¥˜ ë°œìƒ!');
    console.error('â†³ ë©”ì‹œì§€:', err.message);
    console.error('â†³ ìƒíƒœ ì½”ë“œ:', err.response?.status);
    console.error('â†³ ìƒíƒœ í…ìŠ¤íŠ¸:', err.response?.statusText);
    console.error('â†³ ì‘ë‹µ ë°ì´í„°:', JSON.stringify(err.response?.data, null, 2));
    console.error('â†³ ìš”ì²­ ë‚´ìš©:', err.config?.data);

    return res.status(err.response?.status || 500).json({
      error: 'Gemini API í˜¸ì¶œ ì‹¤íŒ¨',
      message: err.response?.data?.error?.message || err.message
    });
  }
});

app.listen(PORT, () => {
  console.log(`âœ… Gemini+Weather ì„œë²„ ì‹¤í–‰ ì¤‘: http://localhost:${PORT}`);
});

